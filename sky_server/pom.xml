<?xml version="1.0" encoding="UTF-8"?>
<!--
    config      ： 配置文件
    controller  ： 控制
    handler     ： 处理器
    interceptor ： 拦截器
    mapper      ： 映射
    service     ： 服务
    启动类： TakeoutApplication.class

    resources：
        - mapper 文件夹： mapper 文件夹下的所有文件
        - application.yml ... ： 配置文件

    设计步骤：需求分析和设计 -> 代码开发 -> 功能测试 -> 代码完善

    关于return Result.success()的括号里是否有参数
    看接口设计里的返回响应里是不是数据结构的data信息里有别的信息即可

    设计到多表查询时，sum(od.number)一定要加上as number，不然属性为number的时候结果为null


    GET请求不需要添加@RequestBody等请求体
-->

<!--  专题一：员工管理  -->
<!--
专题一：员工管理
        功能一：员工管理-新增员工
             一、需求分析和设计：
                1. 要求：有账号，员工姓名，手机号，性别，身份证号
                        其中账号必须是唯一的；手机号和身份证分别为合法的11，18位号码；密码默认是123456（用md5加密）
                2. 接口设计：
                    - 基本信息：
                        Path：/admin/employee  |  Method：POST
                    - 请求参数：
                        Headers：Content-Type：application/json（必须）
                    - Body（为了接受前端数据而设计的实现类）：见 DTO/EmployeeDTO.java
                    - 返回结果：
                        必须：code（Integer 1为成功，0为失败）
                        非必须：message（String），data（Object）
                3. 数据库设计：见 employee表
            二、代码开发：
                根据前端需要设计DTO/EmployeeDTO.java类、  VO/EmployeeVO.java类
                根据数据库表结构，创建实体类 Employee（见 Entity/Employee.java）
                在 Controller -> Service -> ServiceImpl -> Mapper -> Mapper.xml 添加 save 方法
                其中ServiceImpl有一个 对象属性拷贝固定API：BeanUtils.copyProperties(source, target)，然后给Employee设置EmployeeDTO没有的属性
            三、功能测试：
                - 通过接口文档测试：
                    但是在点测试的时候会显示401，是因为我们的interceptor/JwtTokenAdminInterceptor.java拦截了
                    此时就需要先调用一次“员工登录”，在响应内容里边获取一个token，然后把token放
                    文档管理 -> 全局参数设置 -> 添加参数 -> 参数名必须为token(yml中配置) -> 参数值 即可
                - 通过前后端联调测试：
                    http://localhost:8888/login#/employee/add
                    Tip：账号要为小写or数字组合且不重复，手机号一定要为1(3|4|5|6|7|8)开头
            四、完善代码：
                - 录入的用户名已存在，抛出异常后没有处理
                    在 handler/GlobalExceptionHandler.java 中重写exceptionHandler
                    参数：SQLIntegrityConstraintViolationException ex
                    先log一下，然后
                    if (message.contains("Duplicate entry")) {
                        String[] split = message.split(" ");
                        String username = split[2];
                        String msg = "用户名【" + username + "】已存在";
                        return Result.error(msg);
                    } else {
                        return Result.error(MessageConstant.UNKNOWN_ERROR);
                    }

                - 新增员工时，创建人id和修改人id设置为固定值，需要通过哪种方式动态获取当前登录的员工id？
                    答：在员工登录成功后会生成一个JWT令牌，里面有员工id，所以可以通过JWT令牌获取当前登录的员工id
                    在 interceptor/JwtTokenAdminInterceptor.java 中校验 JWT 的时候会获取当前登录的员工id

                    Tip：ThreadLocal 并不是一个 Thread，而是Thread的局部变量。
                         其是为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则无法访问
                         常用方法： void set(T value) || T get() || void remove()
                         分别是设置(当前线程锁对应的线程局部变量)值、获取值、删除值

                     若在JwtTokenAdminInterceptor.java, Controller & ServiceImpl.java 中都加上sout显示线程id，则线程id一致
                     若再发送一次请求，则id会改变但三者id依然一致，所以这三者是一个线程局部变量
                     所以就可以在JwtTokenAdminInterceptor.java 中获取当前登录的员工id，设置成ThreadLocal值，然后在ServiceImpl中获取
                     （设置语句：BaseContext.setCurrentId(id);    获取值：BaseContext.getCurrentId();）
                     详情见sky_common\..\context\BaseContext.java


        功能二：员工分页查询
            一、需求分析和设计
                1. 要求：
                    - 根据页码展示员工数据
                    - 每页展示 10 条员工数据
                    - 分页查询时可以根据需要，输入员工姓名进行查询
                2. 接口设计：
                    - 基本信息：
                        Path：/admin/employee/page  |  Method：GET
                    - 请求参数：
                        name：员工信息 |  page：页码  |  pageSize：每页数据条数
                    - 返回数据：
                        code, message, data(包含total, records(包含id, username, ...))
            二、代码开发：
                1. 设计DTO和实体类：sky_pojo/../DTO/EmployeePageQueryDTO.java，DTO是前端展示的东西
                    为了后端开发，我们给所有的分页查询，统一封装成 sky_common/../result/PageResult.java 对象
                    返回给前端/后端的数据应该为：Result<PageResult>
                2. 之后同上设计
                    Tip：com.github.pagehelper.Page利用分页插件，实现分页查询，会自动添加limit的SQL语句
                    PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
                    Page<Employee> page = employeeMapper.pageQuery(employeePageQueryDTO);
                    long total = page.getTotal();
                    List<Employee> list = page.getResult();
                    然后封装成PageResult对象：PageResult(total, list);
            三、功能测试：
                - 接口文档：http://localhost:8080/doc.html#/
                - 前后端联调：http://localhost:8888/login#/employee
            四、代码完善
                - 日期格式
                    在测试的时候会发现，日期会变成 2025,7,19,21,42,6（接口文档） ， 202571921426（前后端联调）的格式
                    所以需要对
                        · 方式一：属性进行@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")注解，只针对单个注解
                        · 方式二：全局统一日期格式，在WebMvcConfiguration.java 中添加 SpringMVC 的 消息转换器
                                统一对日期进行格式化处理
                    @Override
                    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
                        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
                        converter.setObjectMapper(new JacksonObjectMapper());
                        converters.add(converter);
                    }

        功能三：启动禁用员工账号
            一、需求分析和设计
                1. 业务规则：
                    - 可以对状态 “启用” 的员工账号进行 “禁用” 操作
                    - 可以对状态 “禁用” 的员工账号进行 “启用” 操作
                    - 状态为 “禁用” 的员工账号不能登录系统
                2. 接口设计：
                    - 基本信息：
                        Path：/admin/employee/status/{status}  |  Method：POST
                    - 请求参数：Headers-同专题一  |  路径参数-status  |  Query-id
                    - 返回数据：
                        code, message, data
            二、代码开发：
                public Result startOrStop(@PathVariable("status") Integer status, Long id)

        功能四：编辑员工
            一、需求分析和设计
                1. 业务规则：
                    - 根据 id 查询员工信息
                    - 然后编辑员工信息
                2. 接口设计：
                    · 接口一：根据id查询员工信息（因为涉及到密码保密，所以需要这个功能）
                        查询： Path：/admin/employee/{id}  |  Method：GET
                    · 接口二：编辑员工数据
                        修改： Path：/admin/employee  |  Method：PUT
            二、代码开发：
                public Result<Employee> update(@PathVariable("id") Long id)
                public Result update(@RequestBody EmployeeDTO employeeDTO)
-->

<!--  专题二：分类管理  -->
<!--
专题二：导入分类模块功能代码
            一、需求分析和设计
                1. 业务规则：
                    - 分类名称必须是 唯一 的
                    - 分类按照类型可以分为 菜品分类 和 套餐分类
                    - 新添加的分类状态默认是 禁用 的
                2. 接口设计
                    · 接口一：新增 分类
                        提交： Path：/admin/category  |  Method：POST
                    · 接口二：分类 分页查询
                        查询： Path：/admin/category/page  |  Method：GET
                    · 接口三：启用禁用 分类
                        修改： Path：/admin/category/status/{status}  |  Method：POST
                    · 接口四：根据id删除 分类
                        删除：Path：/admin/category  |  Method：DELETE
                    · 接口五：修改 分类 信息
                        修改： Path：/admin/category  |  Method：PUT
            二、代码开发：
                public Result save(@RequestBody CategoryDTO categoryDTO)
                public Result pageQuery(CategoryPageQueryDTO categoryPageQueryDTO)
                public Result startOrStop(@PathVariable("status") Integer status, Long id)
                public Result deleteById(Long id)
                public void updateInfo(@RequestBody CategoryDTO categoryDTO)
-->

<!--  专题三：公共字段自动填充  -->
<!--
专题三：公共字段自动填充
        一、问题分析：
            - 新增分类时，需要设置创建/更新时间和人（createTime, updateTime, createUser, updateUser）
              这些就是我们的公共字段，就可以使用 “切面” 来解决
              步骤：
                1. 自定义注解 annotation/AutoFill.注解：
                    用于标识需要进行公共字段自动填充的方法
                    加上 @Target(ElementType.METHOD) 和 @Retention(RetentionPolicy.RUNTIME) 注解
                2. 然后创建枚举类：
                    定义操作类型，见 sky_common/../enumeration/OperationType.enum
                3. 在 AutoFill 注解中定义一个属性：
                    表示当前方法使用的操作类型，OperationType value()
                4. 创建切面类 aspect/AutoFillAspect.类：
                    实现公共字段自动填充处理逻辑
                    加上 @Aspect 和 @Component 注解
                    定义方法：void autoFillPointCut()
                        加上 @Pointcut("execution(* com.atguigu.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)") 注解
                    定义方法：void autoFill(JoinPoint joinPoint)
                        加上 @Before("autoFillPointCut()") 注解
                5. 在 Mapper类 中的 需要自动填充的字段的方法 上加上 @AutoFill(Operation.INSERT/UPDATE) 注解
-->

<!--  专题四：文件上传  -->
<!--
专题四：文件上传
        一、需求分析和设计
            接口设计：
                - 基本信息：Path:/admin/common/upload  |  Method：POST
                - 请求参数：
                    Headers-Content-Type(multipart/form-data)  |  Body-file
                - 返回数据：
                    code, message, data(url: 文件上传路径)
        二、代码开发
            开发文件上传接口：
                浏览器 -> 后端服务 -> 阿里云OSS（见通用接口）
                - yml配置：
                    sky:
                      alioss:
                        endpoint: https://oss-cn-beijing.aliyuncs.com   | dev中https://oss-cn-beijing.aliyuncs.com
                        access-key-id: ${ALIYUN_ACCESS_KEY_ID:LTAI5tP}  | dev中LTAI5t5n9iYN1FT85PBbp6jU
                        access-key-secret: ${ALIYUN_ACCESS_KEY_SECRET:<KEY>}    | dev中kaV8c679Zvp407jhPjuowiZK81m4HU
                        bucket-name: ${ALIYUN_OSS_BUCKET:sky-bucket}    | dev中wakadori

                - 新建文件上传类：见sky_common/../utils/AliOssUtil.java

                - 创造配置类：见sky_common/../config/AliOssConfig.java
                @Configuration
                @Slf4j
                public class OssConfiguration {
                    @Bean
                    @ConditionalOnMissingBean
                    public AliOssUtil aliOssUtil(AliOssProperties aliOssProperties) {
                        log.info("开始创建阿里云文件上传工具类对象：{}", aliOssProperties);
                        return new AliOssUtil(
                                aliOssProperties.getEndpoint(),
                                aliOssProperties.getAccessKeyId(),
                                aliOssProperties.getAccessKeySecret(),
                                aliOssProperties.getBucketName()
                        );
                    }
                - 完善Controller：CommonController.java
-->

<!--  专题四：菜品管理  -->
<!--
专题四：菜品管理
        一、需求分析和设计
                1. 业务规则：
                    - 菜品名称不能重复
                    - 菜品必须属于某个分类下，单独存在
                    - 新增菜品可以根据情况选择菜品的口味
                    - 可以一次删除一个菜品，也可以一次删除多个菜品
                    - 起售中的菜品、关联了套餐的菜品不能删除
                    - 删除菜品后，关联的口味数据也需要删除掉
                2. 接口设计
                  ( · 接口零：根据 分类类型 查询 分类列表 ！！！在 CategoryController 中创建
                        - 查询： Path：/admin/category/list  |  Method：GET
                        - SQL语句：select * from category where type = #{type} and status = 1 order by sort asc, create_time desc  )

                    · 接口一：新增 菜品
                        - 提交： Path：/admin/dish  |  Method：POST
                        - 前置接口：接口零 & 批量新增口味（位于DishFlavorsMapper）：
                            insert into dish_flavor (dish_id, name, value) values <foreach ,> (#{dishId}, #{name}, #{value})

                    · 接口二：菜品 分页查询
                        - 查询： Path：/admin/dish/page  |  Method：GET

                    · 接口三：启用禁用 菜品
                        - 修改： Path：/admin/dish/status/{status}  |  Method：POST

                    · 接口四：根据id(批量)删除 菜品
                        - 删除：Path：/admin/dish  |  Method：DELETE
                        - 前置接口：根据 id 查询 dish（主要是Status），根据 多个dishId 查询 setmealId，根据 多个dishId 删除 dishFlavors
                            select d.status from dish d where id = #{id}
                            select setmeal_id from setmeal_dish where dish_id in <foreach , ( )> #{dishId}
                            delete from dish_flavor where dish_id in <foreach , ( )> #{dishId}

                    · 接口五：查询 菜品 详情，通过VO的形式返回，更新需要
                        - 查询： Path：/admin/dish/{id}  |  Method：GET
                        - 前置接口：根据 dishId 查询 口味 信息
                            select * from dish_flavor where dish_id = #{dishId}

                    · 接口六：修改 菜品 信息
                        - 修改： Path：/admin/dish  |  Method：PUT
                        - 前置接口：接口零 & 根据 dishId 删除口味信息，批量新增口味
                            delete from dish_flavor where dish_id = #{id}
                            insert into dish_flavor (dish_id, name, value) values <foreach ,> (#{dishId}, #{name}, #{value})（同上）

                3. 数据库设计：
                    dish 表：(id, name, category_id, price, status, sort, create_time, update_time, create_user, update_user)
                    dish_flavor 表：(id, dish_id, name, value)
                    setmeal_dish 表：(id, setmeal_id, dish_id, count, amount, create_time)

            二、代码开发：
                · public Result save(@RequestBody CategoryDTO categoryDTO)
                    ServiceImpl：
                      - 生成dish对象并copyDTO -> 向菜品表插入数据&获取插入菜品的ID ->
                        生成List<DishFlavor>接受DTO的口味数据 -> 判断flavors!=null&!isEmpty{
                        flavors.forEach给dishFlavors设置得到的dishId} -> 向口味表插入n条数据

                · public Result pageQuery(CategoryPageQueryDTO categoryPageQueryDTO)
                    Mapper.xml ：
                      - 需要对 categoryId 和 Status 进行判断，然后对 name 进行模糊查询

                · public Result startOrStop(@PathVariable("status") Integer status, Long id)
                    Mapper.xml ：
                      - 需要对 updateUser 等值进行赋值

                · public Result deleteById(@RequestParam List<Long> ids)
                    ServiceImpl：
                        - 涉及到多个表语法，所以需要加上@Transactional注解
                        - 循环遍历ids{   先根据 id 获取 dish 数据 -> 判断所删菜品是否启售中{ 是则抛出错误  } ->
                          再根据 dishId 获取 flavors 数据 -> 判断所删菜品是否关联了套餐{ 是则抛出错误  } ->
                          调用dishMapper & dishFlavorMapper 删除 菜品&口味 数据

                · public Result<DishVO> getById(@PathVariable("id") Long id)
                    ServiceImpl：
                        - 先根据 id 获取 dish 数据 -> 再根据 dishId 获取 flavors 数据 -> 一并封装到 DishVO 中返回

                · public void updateInfo(@RequestBody CategoryDTO categoryDTO)
                    ServiceImpl：
                        - 需要新增 “根据id查询菜品信息” 功能，因为只依靠分页查询则会缺少口味数据（见上）
                        - 新建dish对象，并copyDTO -> 调用updateInfo更新菜品信息 -> 从DTO获取dishId & flavors数据 ->
                          根据dishId删除对应的口味数据 -> 判断如果不为空 向口味表插入n条数据
-->

<!--  专题四：套餐管理  -->
<!--
专题四：套餐管理
    功能一：新增套餐：
        一、需求分析和设计
            1. 业务规则
                - 套餐必须属于某个分类、必须包含菜品
                - 新增的套餐默认为停售状态
                - 起售套餐时，如果套餐内包含停售的菜品，则不能起售
                - 可以批量删除套餐，起售中的套餐不能删除（删除时还得删除套餐和菜品的关系）
            2. 接口设计：
              ( · 接口零-1：根据 分类类型 查询 分类列表 ！！！在 CategoryController 中创建
                    - 查询： Path：/admin/category/list  |  Method：GET
                    - SQL语句：select * from category where type = #{type} and status = 1 order by sort asc, create_time desc  )
              ( · 接口零-2：根据 分类id 查询 菜品列表 ！！！在 DishController 中创建
                    - 查询： Path：/admin/dish/list  |  Method：GET
                    - SQL语句：select * from dish where category_id = #{categoryId} and status = 1 order by sort asc, create_time desc  )

                · 接口一：新增套餐
                    - 提交： Path：/admin/setmeal  |  Method：POST
                    - 前置接口： 接口零-1,2 ， 根据 setmealId 查询 dishes， 批量新增套餐菜品关系，
                        select * from dish where category_id = #{categoryId} and status = 1
                        insert into setmeal_dish (setmeal_id, dish_id, name, price, copies) values <foreach ,> (#{setmealDish.setmealId}, #{setmealDish.dishId}, #{setmealDish.name}, #{setmealDish.price}, #{setmealDish.copies})

                · 接口二：套餐 分页查询
                    - 提交： Path：/admin/setmeal/page  |  Method：GET

                · 接口三：启售/停售套餐
                    - 提交： Path：/admin/setmeal  |  Method：POST
                    - 前置接口：根据 setmealId 获取 菜品信息
                        select * from setmeal where id in <foreach , ( )> #{setmealId}

                · 接口四：批量删除套餐
                    - 提交： Path：/admin/setmeal  |  Method：DELETE
                    - 前置接口：根据 setmealIds 获取 套餐信息， 批量删除套餐菜品关系
                        select * from setmeal where id in <foreach , ( )> #{setmealId}
                        delete from setmeal_dish where setmeal_id in <foreach , ( )> #{setmealId}

                · 接口五：根据id查询套餐，用于修改页面回显数据
                    - 提交： Path：/admin/setmeal/get  |  Method：GET
                    - 前置接口：根据 setmealId 获取 菜品信息（前有）

                · 接口六：修改套餐
                    - 更改： Path：/admin/setmeal  |  Method：PUT
                    - 前置接口：根据 setmealId 删除套餐菜品关联关系，批量新增套餐菜品关系（同上）

        二、代码开发
            · public Result save(@RequestBody SetmealDTO setmealDTO)
                ServiceImpl：
                    - 保存套餐基本信息 -> 获取setmealId -> 保存套餐菜品关联关系
                    - 新建Setmeal对象，并copyDTO，设置Status为0，insert ->
                      从setmeal获取setmealId, 从DTO获取setmealDishes ->
                      判断flavors!=null&!isEmpty{ setmealDishes.forEach给setmealDishes设置得到的setmealId } ->
                      setmealDishMapper.insertBatch(setmealDishes);

            · public Result pageQuery(SetmealPageQueryDTO setmealPageQueryDTO)

            · public Result startOrStop(@PathVariable("status") String status, Long id)
                ServiceImpl：
                    - 判断是否是要启用该套餐 -> 判断套餐绑定菜品的状态是否为停售 -> 更新菜品信息
                    - 判断该切换的状态是否为启用 {
                        用List<Dish>获取 dishMapper.getBySetmealId(id) -> 判断dishes不为空 {
                            dishes.foreach( 判断菜品是否停售 -> 是则抛出错误  )
                        }
                      } -> 创建Setmeal对象builder其id,status -> 调用updateStatus

            · public Result deleteBatch(@RequestParam List<Long> ids)
                ServiceImpl：
                    - 判断套餐是否为起售状态 -> 删除套餐菜品关联关系 -> 删除套餐基本信息
                    - 用List<Setmeal>获取 setmealMapper.listByIds(ids) -> 判断setmeals不为空 {
                            setmeals.foreach( 判断套餐是否为起售状态 -> 是则抛出错误  )
                        } -> setmealDishMapper.deleteBatchBySetmealIds(ids) -> setmealMapper.deleteBatch(ids);

            · public Result<SetmealVO> getById(@PathVariable("id") Long id)
                ServiceImpl：
                    - 先根据 id 获取 setmeal 数据 -> 再根据 setmealId 获取 setmealDishes 数据 -> 一并封装到 SetmealVO 中返回

            · public Result<String> updateInfo(@RequestBody SetmealDTO setmealDTO)
                ServiceImpl：
                    - 更新套餐基本信息 -> 删除套餐菜品关联关系 -> 保存新套餐菜品关联关系
-->

<!--  专题五：店铺营业状态设置  -->
<!--
专题五：店铺营业状态设置：
    一、需求分析和设计
        1. 业务规则
            - 只有处于营业状态的店铺才能接收新订单
            - 处于打烊状态下客户无法下单点餐
        2. 接口设计
            · 接口一：设置营业状态
                - 更改： Path：/admin/shop/{status}  |  Method：POST
                - 前置接口：无
            - 接口二：管理端查询营业状态
                - 查询： Path：/admin/shop/status  |  Method：GET
                - 前置接口：无
            - 接口三：用户端查询营业状态
                - 查询： Path：/user/shop/status  |  Method：GET
                - 前置接口：无
        3. 营业状态数据存储方式：基于Redis的字符串来进行存储

    二、代码开发
        · public Result<String> setStatus(@PathVariable("status")Integer status)
        · public Result<Integer> getStatus() * 2
        Tip：
            在admin和user两个包中都有店铺状态的查询接口
            所以要在各自的@RestController中定义不同的value，否则会有Bean冲突
            同时在WebMvcConfiguration.java中进行分组：定义GroupedOpenApi为userApi和adminApi

-->

<!--  专题六：微信登录  -->
<!--
专题六：微信登录
    一、微信登陆流程：
        https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html
        先在微信小程序调用wx.login -> 获取code -> 打开postman/Insomnia -> 填入https://api.weixin.qq.com/sns/jscode2session
            appid : wxe6d729502a0a743b
            secret : 8fcb927e49771ab8ddf0638294c88a79
            js_code : 填写微信小程序console的code
            grant_type : authorization_code
        -> 获取的openid和session_key
    二、需求分析和设计：
        1. 业务规则：
            · 基于微信登录实现小程序的登录功能
            · 如果是新用户则自动完成注册
        2. 接口设计：
            - 提交： Path：/user/user/login  |  Method：POST
            - 前置接口：根据id查询用户信息；插入用户信息
        3. 数据库设计：
            · user表( id, openid, name, phone, sex, age, id_number, avatar, create_user )

    三、代码开发：
        - 在yml配置文件中加入微信小程序appid和secret
            sky: wechat: appid: wxe6d729502a0a743b  |  secret: b7acb15b72ba38d6a2c588c915c5b595
        - 配置为微信用户生成jwt令牌时使用的配置项, 并设置用户的jwt令牌相关配置
            sky: jwt: user-secret-key: itheima  |  user-ttl: 7200000  |  user-token-name: authentication

        - UserController： 调用service登录方法并用User接收 -> 生成jwt令牌 -> 封装UserLoginVO返回
          UserServiceImpl：创建map对象封装微信的请求参数 -> 调用HttpClient5Util.doGet()获取微信返回的json数据（String接收后转为JSONObject）->
                           从json中获取openid（String） -> 判断openid是否为空，如果是则抛出业务异常 -> 通过id检索用户，若为空则抛出业务异常并改为注册 ->
                           创建用户对象，并保存用户信息 -> 返回用户信息
          Tip：其中获取openid的代码为了复用，可以封装成一个方法

        - 还需要进行JwtTokenUserInterceptor.java拦截器的编写，用于拦截用户端的请求并校验jwt令牌
          （直接复制管理员的拦截器并改名即可，但是 从请求头中获取令牌 时，要把getAdminTokenName() 改为 getUserTokenName()
            和 检验令牌 时，要把checkAdminToken() 改为 checkUserToken()，EMP都改成USER即可）
        - 还需要在WebMvcConfiguration.java中配置拦截器，用于拦截用户端的请求并校验jwt令牌 （34，48行）
-->

<!--  专题七：菜品浏览功能  -->
<!--
专题七：菜品浏览功能
    一、需求分析和设计：
        1. 业务规则：
            · 若菜品设置了口味数据，则菜品右下角显示“显示规格”
            · 对于“选择规格”，点击后可以弹出口味数据
            · 对于套餐，点击套餐图片可以跳转到对应套餐有的菜品数据
        2. 接口设计：
            · 接口一：获取分类数据（已有）
                - 查询： Path：/api/setmeal/list  |  Method：GET
                - 前置接口：无
            · 接口二：根据分类id查询菜品（已有）
                - 查询： Path：/api/dish/list  |  Method：GET
                - 前置接口：根据菜品id查询菜品口味数据-List<DishVO>（未有）
            · 接口三：根据分类id查询套餐，并设置条件查询
                - 查询： Path：/api/setmeal/list  |  Method：GET
                - 前置接口：无
            · 接口四：根据套餐id查询套餐详情（已有）
                - 查询： Path：/api/setmeal/dish/{id}  |  Method：GET
                - 前置接口：无
        3. 代码开发：
            - CategoryController：
                - public Result<List<Category>> list(Integer type)
                  根据 type(Category) 查询 List<Category>
            - DishController：
                - public Result<List<DishVO>> list(Long categoryId)
                  根据 categoryId(Dish) 查询 List<DishVO>
                  DishServiceImpl：
                    · public List<DishVO> listWithFlavors(Long categoryId)
                      根据 categoryId 查询 List<Dish> -> 遍历 List<Dish> -> 根据 dishId 查询 List<DishFlavor> -> 封装 DishVO
                      -> 封装 List<DishVO>

            - SetmealController：
                - public Result<List<Setmeal>> list(Long categoryId, String name)
                  根据 categoryId(Setmeal) 查询 List<Setmeal>
                  SetmealServiceImpl：
                    · public List<Setmeal> list(Setmeal setmeal)

                - public Result<List<DishItemVO>> getDishItemVOListBySetmealId(Long setmealId)
                  根据 setmealId(DishItemVO) 获取 List<DishItemVO>
                  DishItemVO是封装了Dish数据和DishFlavor数据的VO类
-->

<!--  专题八：缓存套餐  -->
<!--
    专题八：缓存套餐
        实现思路：
        · 导入Spring Cache和Redis相关maven坐标
        · 在启动类上添加@EnableCaching注解，开启缓存注解功能
        · 在user端接口SetmealController的list方法上添加@Cacheable注解
        · 在admin端接口SetmealController的save,delete,update,startOrStop方法上添加@Cacheable注解
-->

<!--  专题九：购物车管理  -->
<!--
    专题九：购物车管理

    Function-One：新增至购物车
        一、需求分析和设计：
            1. 接口设计：
                - 添加购物车： Path：/user/shoppingCart/add  |  Method：POST
                - 请求参数：套餐id, 菜品id, 口味
                - 前置接口：根据dishId查询菜品数据；根据SetmealId查询套餐数据；根据 用户id、菜品id、菜品口味 获得购物车数据 ； 修改 商品数量（也就是购物车数据）
            2. 数据库设计：
                - 作用：展示存放所选商品的地方
                - 选的什么商品        - 每个商品都买了几个
                - 不同用户的购物车需要区分开
            shopping_card表（id, name, image, user_id, dish_id, setmeal_id, dish_flavor, number, amount, create_time)

        二、代码实现：
            public Result<String> add(@RequestBody ShoppingCartDTO shoppingCartDTO)
            Impl：
                先根据shoppingCard判断购物车中是否有该商品 {
                    获取当前card，设置数量+1，updateNumberById(card)
                } else {
                判断本次添加的是菜品还是套餐{
                    若是菜品，getById(dishId)获取菜品信息，封装该菜品信息至shoppingCard
                    若是套餐，getById(setmealId)获取套餐信息，封装该套餐信息至shoppingCard
                |
                封装shoppingCard数据，保存至数据库

    Function-Two：查看购物车、清空购物车
        一、需求分析和设计：
            1. 接口设计：
                · 查看购物车
                    - 获取购物车数据： Path：/user/shoppingCart/list  |  Method：GET
                    - 前置接口：无
                · 清空购物车
                    - 清空购物车： Path：/user/shoppingCart/clean  |  Method：DELETE
                    - 前置接口：无
        二、代码实现：
            - public Result<List<ShoppingCart>> list()
            - public Result<String> clean()

    Function-Three：减购物车
        一、需求分析和设计：
            1. 业务规则：
                - 修改购物车数量
                - 若修改的购物车数量为0，则删除该购物车数据
            2. 接口设计：
                - 修改购物车数量： Path：/user/shoppingCart/sub  |  Method：POST
                - 请求参数：菜品id，套餐id，数量
                - 前置接口：
                    根据SetmealId查询套餐数据  根据 用户id、菜品id、菜品口味 获得购物车数据
                    根据 ShoppingCart 更新购物车数据         根据 id 删除购物车数据
-->

<!--  专题十：地址簿管理  -->
<!--
专题十：地址簿管理
    一、需求分析和设计：
        1. 业务规则：
        2. 接口设计：
            - 新增地址簿： Path：/user/addressBook/add  |  Method：POST
            - 条件查询当前登录用户的地址信息： Path：/user/addressBook/list  |  Method：GET
            - 查询当前登录用户的默认地址信息： Path：/user/addressBook/default  |  Method：GET
            - 根据id修改地址簿： Path：/user/addressBook/list  |  Method：PUT
            - 根据id删除地址簿： Path：/user/addressBook/delete  |  Method：DELETE
            - 根据id查询地址簿： Path：/user/addressBook/list/{id}  |  Method：GET
            - 设置默认地址： Path：/user/addressBook/setDefault  |  Method：PUT
    二、代码实现
        - public Result<String> save(@RequestBody Address address)
        - public Result<List<Address>> list()
        - public Result<Address> getDefault()
        - public Result<String> update(@RequestBody Address address)
        - public Result<String> delete(@RequestParam Long id)
        - public Result<Address> getById(@PathVariable Long id)
        - public Result<String> setDefault(@RequestBody Address address)
-->

<!--  专题十一：订单管理  -->
<!--

Function-One、用户下单：
    一、需求分析和设计
        1. 业务规则：
            下单信息要有：买的哪些商品？每个商品的数量是多少？（通过购物车）
                       订单总金额是多少？（分菜品费用+其他费用）
                       哪个地址下的单？收货地址是多少？（通过地址簿）
        2. 接口设计：
            - 用户线下单： Path：/order/submit  |  Method：POST
            - 请求参数：
                Body: {addressBookId, amount, deliveryStatus, estimatedDeliveryTime, packAmount, payMethod, remark, tablewareNumber, tablewareStatus}
            - 返回数据：
                code, date(id, order, orderNumber, orderTime), message
        3. 数据库设计：
            一个订单对应多个菜品，每个菜品都有对应的订单明细表
            - 订单表：id, number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark, update_time, create_time, update_user, create_user
            - 订单明细表：id, name, image, order_id, dish_id, setmeal_id, dish_flavor, number, amount
    二、代码实现：
        - public Result<OrderSubmitVO> submit(OrdersSubmitDTO ordersSubmitDTO)
        Impl：
            先处理各种业务异常 -> 向订单表插入一条数据 -> 向订单明细表插入多条数据 -> 删除购物车数据 -> 返回封装VO数据

Function-Two、用户登录
    零、准备工作-准备临时域名
        1. 登录https://dashboard.cpolar.com/ -> 下载cpolar -> 打开cpolar文件夹 -> 打开cmd -> 输入命令：cpolar.exe authtoken +网址验证隧道码
        2. 启动连接：在文件夹cmd -> cpolar.exe http 8080 （若要配置Task -> 更改yml）

    一、需求分析和设计
        1. 业务规则：
            - 创建订单记录，生成唯一订单号
            - 调用微信统一下单API，生成预支付交易单
                下单：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1
                小程序发起支付：https://pay.weixin.qq.com/doc/v2/merchant/4011939566
        2. 接口设计：
            - 接口一：订单支付
                · Path：/order/payment  |  Method：PUT
                · 请求参数：DTO      · 返回数据：VO
                · 前置接口：根据用户id获得用户信息；
            - 接口二：订单支付结果通知
                · Path：/pay/notify  |  Method：POST
                · 前置接口：根据订单号查询订单数据；更新订单数据

    二、代码实现：
        1. 配置文件修改
            - application.yml - 在sky.wechat下新增：
                mchid, mchSerialNo, privateKeyFilePath, apiV3Key,
                weChatPayCertFilePath, notifyUrl, refundNotifyUrl
        2. 核心实现类
            - OrderController - 新增支付接口：
                @PutMapping("/payment")
                public Result<OrderPaymentVO> payment(@RequestBody OrdersPaymentDTO ordersPaymentDTO)

            - PayNotifyController - 新建支付通知控制器：
                @PostMapping("/paySuccess")
                public void paySuccessNotify(HttpServletRequest request, HttpServletResponse response)

            - OrderServiceImpl
                · 支付业务逻辑：
                导入WeChatPayUtil工具类 -> 获取当前登录用户ID -> 调用微信支付接口生成预支付交易单 -> 返回支付参数给前端
                · 支付结果通知：
                根据订单号查询订单 -> 根据订单id更新订单的状态、支付方式、支付状态、结账时间
-->

<!--  专题十二：订单管理-用户端  -->
<!--
    专题十二：订单管理-用户端

    Function-One、查询历史订单
        一、需求分析和设计
            1. 业务规则：
                - 分页查询历史订单
                - 可以根据订单状态查询
                - 展示订单数据时，需要展示的数据包括：下单时间、订单状态、订单金额、订单明细（商品名称、图片）
            2. 接口设计：
                - 查询历史订单： Path：/order/historyOrders  |  Method：GET
                - 请求参数：page，pageSize，status（下封装在OrdersPageQueryDTO）
                - 响应数据：PageResult
                - 前置接口：根据订单id查询订单明细
        二、代码实现：
            - public Result<PageResult> page(OrdersPageQueryDTO ordersPageQueryDTO)

    Function-Two、取消订单
        一、需求分析和设计
            1. 业务规则：
                - 订单处于未支付、未接单状态时，可以直接取消订单（若支付了未接单则退回支付金额）
                - 若处于已接单、待派送中时，需要先联系商家进行取消订单
                - 取消订单后，要将订单状态修改为“已取消”
            2. 接口设计：
                - 订单取消： Path：/order/cancel  |  Method：PUT
                - 前置接口：根据订单id查询订单数据

        二、代码实现：
            - public Result<String> cancel(Long id)

    Function-Three、再来一单
        一、需求分析和设计
            1. 业务规则：
                - 再来一单就是将原订单中的商品重新加入到购物车中
            2. 接口设计：
                - 再来一单： Path：/order/repetition/{id}  |  Method：POST
                - 前置接口：根据订单id检索订单详情信息，批量新增购物车数据

        二、代码实现：
            - public Result<String> again(@PathVariable Long id)
-->

<!--  专题十三：订单管理-管理端  -->
<!--
    专题十三：订单管理-用户端

    Function-One、订单分页查询
        一、需求分析和设计
            1. 业务规则：
                - 可以用：手机号/订单号/订单状态/模糊名查询
                - 搜索内容为空，提示未找到相关订单
                - 分页展示搜索到的订单数据
                - 将每一条订单菜品信息拼接为字符串（格式：宫保鸡丁*3；）并拼装为字符串
            2. 接口设计：
                - 订单分页查询： Path：/order/page  |  Method：GET
                - 搜索参数：page，pageSize，phone，status，begin，end（下封装在OrdersPageQueryDTO）
                - 响应数据：PageResult
        二、代码实现：
            - public PageResult page(OrdersPageQueryDTO ordersPageQueryDTO)

    Function-Two、各个状态的订单数量统计
        一、需求分析和设计
            2. 接口设计：
                - 订单状态数量统计： Path：/order/statistics  |  Method：GET
                - 响应数据：待接单数量，待派送数量，派送中数量（封装成VO）
                - 前置接口：
        二、代码实现：
            - public OrderStatisticsVO statistics()

    Function-Three、订单详情查询
        一、需求分析和设计
            1. 业务规则：
                - 订单详情页面需要展示订单基本信息
                - 订单详情页面需要展示订单明细数据
            2. 接口设计：
                - 订单详情查询： Path：/order/details/{id}  |  Method：GET
                - 请求参数：id
                - 响应数据：OrderVO
                - 前置接口：根据订单id查询订单数据,订单明细数据
        二、代码实现：
            - public OrderVO details(Long id)

    Function-Four、接单
        一、需求分析和设计
            1. 业务规则：
                - 商家接单其实就是将订单的状态修改为“已接单”
                - 只有订单处于“待接单”状态时可以执行接单操作（不需要进行该代码实现）
            2. 接口设计：
                - 接单： Path：/order/start  |  Method：PUT
                - 请求参数： id, status（orders里的属性，封装成OrdersConfirmDTO）
                - 前置接口：根据Orders对象更新订单数据（利用id定位然后修改status数据）
        二、代码实现：
            - public Result<String> confirm(@RequestBody OrdersConfirmDTO ordersConfirmDTO)

    Function-Five、拒单
        一、需求分析和设计
            1. 业务规则：
                - 拒单就是将订单的状态修改为“已取消”
                - 只有订单处于“待接单”状态时可以执行拒单操作,若用户已支付则进行退款
                - 商家拒单时需要指定拒单原因
            2. 接口设计：
                - 拒单： Path：/order/reject  |  Method：PUT
                - 拒单参数：id, status, reason（封装成OrdersRejectionDTO）
                - 前置接口：根据id查询订单数据，根据订单数据修改订单
        二、代码实现：
            - public Result<String> rejection(@RequestBody OrdersRejectionDTO ordersRejectionDTO) throws Exception

    Function-Six、取消订单
        一、需求分析和设计
            1. 业务规则：
                - 就是把上边的拒单功能改一下，改为取消订单
                下略

    Function-Seven、派送订单
        一、需求分析和设计
            1. 业务规则：
                - 派送订单就是将订单的状态修改为“派送中”
                - 只有订单处于“已接单”状态时可以执行派送操作
            2. 接口设计：
                - 派送订单： Path：/order/delivery/{id}  |  Method：PUT
                - 前置接口：根据id查询订单数据，根据订单数据修改订单
        二、代码实现：
            - public void delivery(Long id)

    Function-Eight、完成订单
        一、需求分析和设计
            1. 业务规则：
                - 完成订单就是将订单的状态修改为“完成”
                - 只有订单处于“派送中”状态时可以执行完成操作
            2. 接口设计：
                - 完成订单： Path：/order/complete/{id}  |  Method：PUT
                - 前置接口：根据id查询订单数据，根据订单数据修改订单
        二、代码实现：
            - public void complete(Long id)
-->

<!--  专题十四：百度地图API调用  -->
<!--
    专题十四：百度地图API调用

    一、前置需要：
        1. 登录https://lbsyun.baidu.com/apiconsole/authflow/authresult
        2. 创建引用获取ak
        3. yml文件中添加自定义：sky: shop : address 和 sky: baidu : ak，并在OrderServiceImpl中添加private
        4. 提供验证方法：public String checkOutOfRange(String address)
-->

<!--  专题十五：实现定时通知/业务修改  -->
<!--
    专题十五：实现定时通知/业务修改：定时订单状态更正

    一、需求分析和设计
        1. 业务规则：
            - 订单未支付超过15分钟，自动取消订单
            - 每天凌晨1点检查一次，若订单处于“派送中”状态，则修改订单状态为“已完成”
        2. 接口设计：
            - 根据status和orderTime查询订单数据
            - 请求参数：status, orderTime
            - 响应数据：List<Orders>
            - 前置接口：根据订单数据修改订单
    二、代码实现：
        见 OrderTask.java
-->

<!-- 专题十六：实现来单提醒  -->
<!--
    专题十六：实现来单提醒/用户催单提醒

    Function-One、用户来单提醒
    一、需求分析和设计
        1. 业务规则：
            - 通过WebSocket实现管理端页面和服务端保持长连接状态
            - 当客户支付后，调用WebSocket相关API实现服务端和客户端的推送消息
            - 客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应消息的提示和语音播报
            - 约定服务端发送给客户端浏览器的数据格式为JSON，字段包括：type, orderId, content（type消息类型，orderId订单id，content内容）
    二、代码实现：
        - 在OrderServiceImpl的paySuccess中添加如下业务
            在更新后 创建Map对象储存type, orderId, content
            -> String json = JSON.toJSONString(map); -> webSocketServer.sendAll(json);
            -> 更改yml的wechat: notifyUrl的为临时域名网址/notify/paySuccess, refundNotifyUrl同理

    Function-Two、用户催单提醒
    一、需求分析和设计
        1. 业务规则：
            - 同上
            - 只有订单处于“待派送”状态时，可以执行催单操作
        2. 接口设计：
            - 催单： Path：/order/reminder/{id}  |  Method：PUT

    二、代码实现：
        - public Result<String> reminder(@PathVariable Long id)

-->

<!-- 专题十七：图标统计  -->
<!--

    专题十七：图标统计

    Function-One：营业额统计
    一、需求分析和设计
        1. 业务规则：
            - 营业额指订单状态为已完成订单金额合计
            - 基于可视化报表的折线图展示营业额数据，x为日期，y为营业额
            - 根据时间选择区间，展示每天的营业额数据
        2. 接口设计：
            - 营业额统计： Path：/admin/report/turnoverStatistic  |  Method：GET
            - 请求参数：begin, end
            - 响应数据：日期列表，营业额列表
    二、代码实现：
        - public TurnoverReportVO turnoverStatistics(LocalDate begin, LocalDate end)

    Function-Two：用户统计
    一、需求分析和设计
        1. 业务规则：
            - 基于可视化报表的折线图展示用户数据，x为日期，y为用户数
            - 根据时间选择区间，展示每天的用户总量和！新增用户数量
        2. 接口设计：
            - 用户统计： Path：/admin/report/userStatistic  |  Method：GET
            - 请求参数：begin, end
            - 响应数据：日期列表，用户数列表，新增用户数列表
    二、代码实现：
        - public UserReportVO userStatistics(LocalDate begin, LocalDate end)

    Function-Three：订单统计
    一、需求分析和设计
        1. 业务规则：
            - 有效订单 指的是订单处于“已完成”状态的订单
            - 基于可视化报表的折线图展示 总订单，有效订单 数据，x为日期，y为订单数
            - 根据时间选择区间，展示每天的订单数量，订单完成率
        2. 接口设计：
            - 订单统计： Path：/admin/report/orderStatistic  |  Method：GET
            - 响应数据：日期列表，总订单列表，有效订单列表，订单完成率列表，订单总数，有效订单数，有效订单率
    二、代码实现：
        - public OrderReportVO ordersStatistics(LocalDate begin, LocalDate end)

    Function-Four：销量前十商品展示
    一、需求分析和设计
        1. 业务规则：
            - 根据时间选择区间，展示销量前十的商品（包括菜品和套餐）
            - 基于可视化报表的柱状图降序展示商品销量
            - 此处的销量为商品销售的份数
        2. 接口设计：
            - 销量前十商品展示： Path：/admin/report/top10  |  Method：GET
            - 响应数据：名称列表，销量列表
    二、代码实现：
        - public List<SalesTop10ReportVO> getTop10(LocalDate begin, LocalDate end)
-->

<!--  专题十八：工作台  -->
<!--
    专题十八：工作台

    Function-One：今日数据
    一、需求分析和设计
        1. 业务规则：
            - 营业额：已完成的订单的总金额    - 有效订单：已完成订单数量      - 新增用户数
            - 订单完成率     - 平均客单价：营业额/有效订单
        2. 接口设计：
            - 今日数据： Path：/admin/workspace/businessData  |  Method：GET
            - 响应数据：营业额，有效订单，新增用户数，订单完成率，平均客单价

    Function-Two：其他管理模块：
    一、需求分析和设计
        1. 业务规则：
            - 订单 管理总览：统计 “待接单”，“待派送”，“已完成”，“已取消”，“全部订单” 数量
            - 菜品 管理总览：统计 “停售”，“起售” 菜品数量
            - 套餐 管理总览：统计 “停售”，“起售” 套餐数量
        2. 接口设计：
            - 订单 管理模块： Path：/admin/workspace/overviewOrders |  Method：GET
              响应数据：待接单，待派送，已完成，已取消，全部订单
            - 菜品 管理模块： Path：/admin/workspace/overviewDishes |  Method：GET
              响应数据：停售，起售
            - 套餐 管理模块： Path：/admin/workspace/overSetmeals   |  Method：GET
              响应数据：停售，起售
-->

<!--  专题十九：导出运营数据Excel报表  -->
<!--
     专题十九：导出运营数据Excel报表

     一、需求分析和设计
        1. 业务规则：
           - 导出最近30天的Excel报表，分为概览数据和明细数据
           - 概览数据包括：营业额、订单完成率、新增用户数、有效订单、平均客单价
           - 明细数据包括：日期、营业额、有效订单、订单完成率、平均客单价、新增用户数
        2. 接口设计：
            - 导出运营数据Excel报表： Path：/admin/report/export  |  Method：GET
            注意：当前接口没有返回数据，因为报表输出功能本质上是文件下载，服务端会通过输出流下载到客户端浏览器、
                 本来没参数的，但是需要一个response参数，用来返回文件下载的响应信息

-->
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.atguigu</groupId>
        <artifactId>TakeOut</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>sky_server</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>com.atguigu</groupId>
            <artifactId>sky_common</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>com.atguigu</groupId>
            <artifactId>sky_pojo</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper-spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>

        <!-- 最新版本的knife4j，支持Spring Boot 3.x -->
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
            <version>4.3.0</version>
        </dependency>

        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
        </dependency>


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>

        <!-- HttpClient 5.x (版本由父pom管理) -->
        <dependency>
            <groupId>org.apache.httpcomponents.client5</groupId>
            <artifactId>httpclient5</artifactId>
        </dependency>

        <!--   Spring Cache    -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-cache</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
